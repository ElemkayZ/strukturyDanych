complexity of different operations in a priority queue
Operation	Unordered Array	Ordered Array	Binary Heap	Binary Search Tree
Insert	0(1)	0(N)	0(log(N))	0(log(N))
Peek	0(N)	0(1)	0(1)	0(1)
Delete	0(N)	0(1)	0(log (N))	0(log(N))


The main differences between a binary heap and a binary search tree (BST) used as a max priority queue lie in their structure, properties, and performance characteristics:

Structure:
Binary Heap: Binary heap is a complete binary tree where each node has at most two children, and the tree is filled from left to right at each level. It is typically implemented as an array, where the parent's key is always greater than or equal to its children's keys (max heap property) or less than or equal to its children's keys (min heap property).
Binary Search Tree: BST is a binary tree where each node has at most two children, and the left child's key is less than the parent's key, while the right child's key is greater than the parent's key. It does not necessarily have a fixed structure like a heap; instead, it adapts dynamically as elements are inserted or deleted.
Priority Queue Operations:
Binary Heap: Binary heap supports efficient priority queue operations such as insertion, deletion of the maximum (or minimum) element, and extracting the maximum (or minimum) element. These operations typically have logarithmic time complexity (O(log n)).
Binary Search Tree: BST also supports priority queue operations, but their time complexity depends on the structure of the tree. While insertion and deletion operations have logarithmic time complexity on average (O(log n)), they can degrade to linear time complexity (O(n)) in the worst-case scenario if the tree becomes unbalanced.
Search Performance:
Binary Heap: Binary heap is optimized for priority queue operations and does not support efficient searching for arbitrary keys. Searching for a specific key in a binary heap would require linear time complexity (O(n)).in a standard binary heap implementation, directly modifying the priority of an element might not be efficient because locating the element within the heap can take linear time.
To efficiently modify the priority of an element, you typically need to implement an additional data structure to track the position of each element within the heap. One common approach is to use a hash table (or dictionary in Python) to store the mapping between elements and their indices in the heap array.
Binary Search Tree: BST is well-suited for searching operations. Searching for a specific key in a BST has logarithmic time complexity (O(log n)), making it efficient.
Balanced vs. Unbalanced:
Binary Heap: Binary heap maintains a balanced structure by design, ensuring efficient priority queue operations. However, it does not necessarily maintain the same balanced structure as a BST.
Binary Search Tree: BST's structure depends on the order of insertion and deletion operations. It can become unbalanced, leading to degraded performance for priority queue operations.
In summary, while both binary heap and binary search tree can be used to implement a max priority queue, they have different structures and performance characteristics. Binary heap is optimized for priority queue operations and maintains a balanced structure, while a binary search tree provides flexibility for searching but may require rebalancing to maintain optimal performance. The choice between them depends on the specific requirements and trade-offs of the application.





